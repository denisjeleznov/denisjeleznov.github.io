## Базовые понятия. Выражения (Expressions) vs Инструкции (Statements)
* Выражения - возвращают значения
* Инструкции - передают управление

Например, в java if это инструкция:
```
if (x > y)
 return x
else 
 return y
```
а в kotlin if это выражение:
```
max = if(x > y) x else y
```


## Базовые понятия. Объекты vs Структуры данных

Структуры данных - можно сравнить со стандартными блоками конструктора LEGO. Они реализуют хорошо известные (часто используемые) абстракции и формируют базу для реализации Объектов. 

Работа программиста (написание кода программы) заключается в том, чтобы сформулировать решение задачи на "человеческом" языке а затем - трансформировать это решение в компьютерный язык (реализовать Объекты и их взаимодействие через методы).

Объекты **скрывают** структуру своих данных. Структуры - напротив, позволяют работать со своими данными **напрямую**.

ArrayList и LinkedList из JDK, формально, являются объектами классов, однако, по сути, это структуры - работа с ними **предполагает знание внутреннего устройства**.


## Базовые понятия. Библиотеки vs Фреймворки
* Код пользователя вызывает код библиотеки
* Код фреймворка вызывает код пользователя
* оба типа артефактов **добавляют внешние (включая транзитивные) зависимости**

При появлении желания добавить в проект новую библиотеку или фреймворк важно:
1. проанализировать последствия (цену сопровождения изменений в новых зависимостях)
2. подумать над реализацией anticorruption layer - слоя абстракции для минимизации влияния изменний во внешних зависимостях.
3. при наличии выбора, подключать библиотеку (не фреймворк) ибо код пользователя сильнее связан с кодом фреймворка (для обеспечения вызова со стороны фреймворка).


## <a name="mudules-vs-components"></a>Базовые понятия. Модули vs Компоненты
Модули это **артефакты языка** или среды разработки. Они дают разработчику возможность группировать логически связанный код для повторного использования, в частности, для использования в **различных** системах. 

Компоненты это законченные и готовые к использованию в условиях конкретной информационной системы **единицы поставки функционала**. Как правило, "в чистом виде" (без доработок) компоненты **не переиспользуются** между различными системами.

Итого: 
* модуль это единица переиспользования кода на стадии разработки
* компонент это единица поставки фунционала на стадии сопровождения
* модуль это способ объединения кода в целях упрощения повторного использования
* компопент это способ разделения функционала в целях упрощения незавимой поставки
* зависимости между модулями, как правило, возникают compile time
* зависимости между компонентами, как правило, возникают runtime

Например, library - библиотека кода для повторного использования является модулем, а OrderService - компонент, обрабатывающий заказы в соответствии с бизнес-правилами конкретной информационной системы, является компонентом.

Одна из важнейших задач Архитектора - разделить будущую систему на компоненты и определить границы между ними. Для этого можно применить аналогию из физики - сильное взаимодействие  (обеспечивает устойчивость атомных ядер). В мире ИТ аналогом сильного взаимодействия можно считать бизнес-транзакции. Соответственно, границы между компонентами логично провести по границе бизнес-транзакций (транзакция должна полностью "помещаться" внутри одного компонента. Как следствие - разработка архитектуры должна начинаться с изучения бизнес-процессов с целью сбора информации о бизнес-транзакциях.


## Базовые понятия. События vs Сообщения
Событие (event) связывает **конкретный источник** события с **анонимным получателем** (обработчиком события). Как правило, событие характеризуется источником и типом.

Сообщение (message) связывает любого (возможно, анонимного) **Отправителя** с **конкретным Получателем** (адресатом сообщения). Как правило, сообщение характеризуется Получателем и телом (полезной нагрузкой). Факт того, что событие однозначно связано с Получателем позволяет реализовать последовательную обработку (обработка следующего сообщения может ссылаться на состояние, хранящееся в Получателя, которое было сформировано при обработке предыдущего сообщения).

Обработка событий может порождать отправку сообщений и наоборот.

События и сообщения являются основными носителями информации в EDA - событийно ориентированной архитектуре. Этот подход позволяет достичь максимальной изоляции компонентов системы. Однако, высокая степень изоляции существенно осложняет реализацию функционала, который требует синхронизации между компонентами (например, реализация новой бизнес-транзакции). Поэтому, в EDA нужно либо особенно тщательно подходить к вопросу определения границ между компонентами системы либо - заранее предусмотреть роль координатора (учитывая, что он повышает не желательную связность становится "единой точкой отказа").


## Базовые понятия. Concurrency vs Parallelism
Concurrency is an aspect of the problem domain — your program needs to handle multiple simultaneous (or near-simultaneous) events. Parallelism, by contrast, is an aspect of the solution domain.

Concurrency is not a way to make a program run faster. It is not a complex juggling trick that ninja coders use to keep multiple balls in the air at one time. On the contrary, it is the apparent sequential execution of a program that is the complex trick. Sequential execution is an illusion maintained by a cabal of compiler writers and hardware architects. Concurrency is simply the relaxation of a fabricated constraint.”

(C) Meike, G. Blake. “Android Concurrency”

Таким образом, современный runtime практически всегда предполагает конкурентное выполнение кода. В этом смысле, Concurrency напоминает Р-компонент из знаменитой CAP-теоремы. Они оба - "данность" современного мира разработки ПО (должно работать в многоядерном runtime и уметь горизонтально масштабироваться по множеству узлов - быть partition tolerance).


## Функциональное программирование vs Объектно ориентированное в условиях современного runtime
Выбор подхода к разработке ПО для современной конкурентной среды выполнения (concurrency runtime) в первую очередь зависит от способа работы с данными.

ООП предполагает **совместный** доступ к данным внутри объекта из методов объекта. Конкурентная среда выполнения создаёт условия для **одновременного** доступа к данными, что приводит к  возникновению неопределённостей типа "гонки" (race condition). Устранение неопределённости требует синхронизации что существенно влияет на производительность (фактически, "засинхронизированный" многопоточный код выполняется медленнее однопоточного).

В функциональном подходе данные представляются в "математическим" смысле (результат работы функции не может изменить её аргументы) а работа с ними напоминает конвейер. В этом подходе, практически, отсутствует проблема совместного доступа к данным, однако, требуются дополнительные ресурсы на обеспечение независимости данных (много операций копирования - больше нагрузка на подсистему управления памятью).

Таким образом, становится очевидным причина возобновления интереса к функциональному подходу для создания систем, эффективно работающих в современных runtime.


## Определение Архитектуры (по ГОСТ)
Архитектура - принципиальная организация системы, воплощённая в её элементах, способах их взаимоотношений  друг с другом и со средой а также - принципы, направляющие развитие системы.

Неожиданно для меня, ГОСТ-определение архитектуры ПО оказалось лидером по количеству смысла на единицу текста.


## Основное требование к архитектуре ПО
Исторически, программное обеспечение (softwate vs hardware) появилось в ответ на требование обеспечить гибкость - легко и быстро менять поведение машин. Для обеспечения гибкости, нужно как можно дольше иметь как можно больше вариантов развития (эволюции) системы.

Таким образом, хорошая архитектруа должна **обеспечивать высокую скорость эволюции информационной системы**, что достигается за счёт:
1. предоставления разнообразия вариантов использования
2. простоты внесения изменений, тестирования, развёртывания и сопровождения

Поэтому, при разработке архитектуры основной акцент внимания уделяется не реализации функциональных требований на текущий момент а обеспечению развития (эволюции) системы во времени.

**Архитектура** программной системы — это **форма**, которая образуется делением системы на **компоненты**.  

Любую программную систему можно, условно, разделить на два основных компонента:              
1. ядро (бизнес-логика). 
2. оболочка (взаимодействие бизнес-логики с окружением).

Цель архитектора — создать такую форму, которая сделает ядро самым важным компонентом, а оболочку — не зависимой от ядра. Это позволит откладывать и задерживать принятие решений об оболочке для того, чтобы накопить информацию (во время работы над ядром) для обоснованного выбора.


## Layered Architecture vs Domain Driven Desing (DDD)
"Слоистая" (layered) архитектура концентрируется на разделении системы на слои по зонам ответственности (каждый слой реализует свою, уникальную зону ответственности). 

Более того - слои формируют иерархию, которая эффективно ограничивает "видимость" между слоями только соседними. Соседние слои взаимодействуют через контракт. 

Стабильность и скорость эволюции системы со "слоистой" архитектурой зависит от стабильности контракта на границе слоёв.

DDD рекомендует делить систему на [компоненты](#mudules-vs-components) - bounded context. Как правило, границы bounded context определяются границей бизнес-транзакции. Реализация бизнес-транзакции требует привлечения функционала со всех зон ответственности "слоистой" архитектуры.

Таким образом, "слоистая" архитектура и DDD  представляют собой ортогональные концепции. Попытка совместного применения этих концепций в рамках одной системы лишает возможности использовать преимущества и усиливает недостатки обоих подходов.

Вывод - "слоистая" архитектура и DDD слабо применимы в рамках одной системы.


## Источник вдохновения для проектирования информационной системы
Поиск метафоры в "мире механизмов" (механических систем) обречён на провал из-за того, что механические системы, как правило, сочетают в себе те черты, которых нужно избегать при проектировании информационных систем - хрупкость и жёсткость.

Аналогии нужно искать в биологии.


## Принципы проектирования и сопровождения высоконагруженной системы:

### Принципы проектирования:
1.	Разбиение на блоки – распределение нагрузки
2.	Резервирование подсистем – устойчивость к внутренним отказам
3.	Автономность – устойчивость к отказам внешних систем

### Принципы развёртывания:
1.	Плавность – последовательное внедрение (пилотный блок, основной блок, резервный блок)
2.	Рубильники – возможность оперативного включения/отключения/переключения версии индивидуально для каждого изменения
3.	Обратная совместимость и обратимость изменений


## Надёжность распределённой системы. Паттерн "Наблюдение"
Система считается надёжной, если сбой в одном или нескольких её компонентов не приводит к отказу - система продолжает предоставлять сервис с заявленными параметрами качества.

Один из шаблонов для реализации надёжной системы - "Наблюдение" (supervision) предполагает эскалацию "проблем" при вызове сервиса его "Наблюдателю" (supervisor). В данном контексте, к "проблемным" относятся ситуации, возникновения системных (инфраструктурных) ошибок, например, потери соединения с БД или внешним сервисом. 

Применение шаблона "Наблюдение" позволяет отделить кодовую базу обработки ошибок бизнес-логики от логики обработки системных ошибок. При использовании этого шаблона важно чётко "соблюдать водораздел" - "Наблюдатель" может управлять жизненным циклом объектов наблюдения, но не должен знать о деталях реализуемой ими бизнес-логики.

Шаблон "наблюдение" широко используется в модели программирования, основанной на акторах, а также - в решениях для балансировки нагрузки.


## 100% надёжность не требуется реальной информационной системе
Ни один пользователь не сможет убедиться и оценить 100% надёжную систему из-за того, что для доступа к ней используется большое количество промежуточных систем (WiFi, DNS, провайдеры,...) с надёжностью ниже 100%.

Промежуточные системы привносят случайные сбои, дискредитирующие надёжность целевой системы.

Кроме того, нужно учитывать, что активность по усилению  надёжности, как правило, влияет на скорость внесения изменений - тормозит развитие системы.

Управление надёжностью информационной системы предполагает выявление основных рисков и управление ими а не стремление повысить количество "девяток".


## Компромисс между доступностью и согласованностью распределённой системы
Информация в физическом мире распространяется с конечной скоростью - изменения в распределённой системе не могут моментально появиться во всех её частях. CAP-теорема, фактически, постулирует это ограничение в отсутствии возможности создать распределённую систему со 100% доступностью и согласованностью.

Доступность и согласованность реальной распределённой системы это компромисс с ограничениями физического мира, финансовыми рисками и удобством использования. 

Например, в случае отсутствия связи с банком, банкомат не откажет в выдаче денег (сервис доступен), но ограничит максимально запрашиваемую сумму (в рамках установленных финансовых рисков).

Другой пример - CRDT-структуры данных, использованием которых предполагает, что система доступна, но периодически находится в не согласованном состоянии.


## Количественные характеристики доступности/качества обслуживания
Качество обслуживания информационной системы характеризуют три SL*-параметра:
1. SLI - service level indicator - описывает измеримые для внешнего наблюдателя параметры работы системы (время отклика, пропускная способность, количество ошибок,...)
2. SLO - service level objective - целевой показатель для SLI
3. SLA - service level agreement - последствия выхода SLI за пределы SLO


## Изолированная согласованность
Реализация строгой (в каждой точке, в любой момент времени) согласованности в распределённой системе не достижима из-за конфликта требования по доступности с конечной скоростью распространения информации.

Изолированная согласованность это компромиссное решение, которое предполагает поддержание согласованности только в рамках отдельных частей системы - "автономных доменов". 

Изолированная согласованность достижима за счёт того:
1.	что данные внутри домена не распределены
2.	транзакции не выходят за рамки домена.

Одна из задач, решаемых в ходе разработки архитектуры распределённой системы - выделение "автономных доменов" данных. Как правило, границы доменов определяются границами **бизнес**-транзакций.

Для перемещения данных между "автономными доменами" используется паттерн "сага".


## Cluster vs Distributed application
Кластер, по сути, представляет собой группу "сильно связанных узлов", совместно представляющих собой одну "виртуальную" машину.

Таким образом, система, предназначенная для работы на кластере, может разрабатываться "как обычная" (не распределённая).

Распределённая система должна изначально разрабатываться с учётом проблем (доступность, согласованность данных, ...), возникающих при взаимодействии между слабо связанными узлами.


## "Жизнь" после распределённых транзакций (по мотивам [статьи](http://adrianmarriott.net/logosroot/papers/LifeBeyondTxns.pdf) Pat Helland)
Идея, лежащая за различными механизмами распределённых транзакций, заключается в предоставлении разработчику абстракции глобального строгого порядка (global serializability).

Абстракция глобального строгого порядка позволяет атомарно изменять  данные, распределённые по множеству узлов распределённой системы.

Распределённые транзакции не пригодны для создания масштабируемых распределённых систем из-за их несовместимости с требованием по обеспечению высокой доступности.

Строгий порядок операций в масштабируемой распределённой системе достигается только внутри ограниченной области видимости (scope) - внутри одного узла сети (или кластера).

Масштабируемые распределённые системы строятся вокруг абстракции сущности (entity), которая представляет собой хранимое состояние (произвольной структуры) адресуемое по уникальному идентификатору. Например, сущность может быть файлом или набором записей в различных таблицах, адресуемых по единому уникальному идентификатору. 

В целях достижения масштабируемости, распределённая система накладывает следующие ограничения на сущности:
1. Строгий порядок операций и атомарные транзакции ограничены границами одной сущности - при этом сущность может адресоваться только уникальным (постоянным) идентификатором - (альтернативные индексы не применимы из-за того, что синхронизация между идентификатором и альтернативным индексом не масштабируется).
2. Данные сущностей не должны пересекаться
3. Возможность сущности перемещаться между узлами сети накладывает ограничение на участие нескольких сущностей в одной транзакции.

Для построения успешной масштабируемой распределённой системы, разработчики бизнес-процессов, должны  проектировать бизнес-процессы вокруг абстракции сущность (entity) и знать об ограничениях с этим связанных (см. выше). В частности - отсутствие синхронизации между состоянием различных сущностей должно учитываться в бизнес-процессах.

Гибкость масштабируемой распределённой системы обеспечивается её "слоистой" структурой, предполагающей наличие двух слоёв - верхний и нижний.  Верхний слой этой структуры реализует бизнес-логику, манипулирующую внутренней структурой сущностей. Нижний слой обеспечивает масштабирование, доставляя сообщения и распределяя сущности по узлам сети в зависимости от нагрузки на систему и доступности узлов.

Примером слоистой архитектуры можно считать систему, построенную поверх кластера узлов. Код нижнего слоя формирует из множества узлов единую среду выполнения, внутри которой работает код верхнего слоя.

Информация в распределённой системе передаётся в виде событий и сообщений. Как правило, события передаются с гарантией доставки "максимум один раз" (at most once) - могут быть потеряны,  а сообщений - "как минимум один раз" (at least once) - могут дублироваться. Кроме того, события и сообщения могут передаваться с нарушением порядка (out of order).

Сообщения, как правило, передаются между сущностями и адресуются уникальными идентификаторами сущностей. Для корректной обработки (предотвращения дублирования) с учётом доставки сообщений at least once и out of order, сущности хранят в себе "состояние партнёра" (pathner activity).

Шаблоны проектирования распределённой масштабируемой системы:
1. Entity - определяет границы согласованного (атомарного) изменения данных
2. Workflow - машина-состояний для решения "проблемы неопределённости" (отсутствия синхронизации между состояниями различных Entity). Entity хранит в workflow свою версию состояния для каждого "партнёра"
3. Tentative opration - "оптимистичное" выполнение, предполагающее возможность отмены - ещё один инструмент для решения "проблемы неопределённости". 
4. Activity - механизм хранения состояние. используется для решения проблем идемпотентности и неопределённости. Entity использует аctivity для хранения своего представления и состоянии партнёров и отслеживания сообщений, принятых от партнёров.


## Распределённая блокировка
Традиционно, для организации монопольного доступа к ресурсу используются блокировки.

В случае распределённых систем эффективная реализация блокировки требует дополнительной проверки на стороне стороне ресурса - он должен проверять не только наличие маркера доступа но и его версию.

Например, узел А получает маркер доступа к ресурсу, запускает операцию и... впадает в ступор, например, из-за начавшейся сборки мусора. За это время маркер доступа узла А к ресурсу "протухает" и доступ к ресурсу получает узел B. 

Через некоторое время, узел А "просыпается" и решает продолжить операцию с ресурсом (состояние которого уже было изменено узлом B) - возникает конфликт.

Для того, чтобы избежать конфликта, при обработке запроса ресурс должен проверять не только наличие маркера доступа, но и его версию и откатывать операции с "протухшей" версией маркера.


## Распределённые системы - Best Efforts 1PC pattern
Является "легковесной" альтернативой (не эквивалентной заменой) классическим (2PC) распределённым транзакциям.

1PC pattern предполагает что:
1. имеется "оркестратор", который последовательно запускает операции над списком ресурсов
2. операций, выполняемые над ресурсами, идемпотентны
3. операции, выполняемые над ресурсами упорядочены (следующая операция должна выполняться только при условии завершения предыдущей

Главная идея 1PC pattern заключается в том, что подтверждение (commit) операций над ресурсами выполняется в порядке, обратном порядку выполнения операций. 

Пример: Запись в базу инициируемая получением сообщения из очереди. 
Здесь два ресурса:
1. Очередь сообщений
2. БД

И две операции:
1. Получить сообщение из очереди
2. Записать в БД

Порядок выполнения операций:
1. Получить сообщение
2. Записать в БД

Порядок подтверждения операций:
1. Подтвердить запись в БД
2. Подтвердить получение сообщения

При условии идемпотентности операции записи в БД, возможно использование паттерна 1PC pattern без риска потери сообщений или дублирования записей в БД.


## Latency vs Response Time vs Service Time
Latency - время ожидания. Это время которое запрос ожидает начала его обработки. Ожидающий запрос, обычно, находится в очереди на соответствующем слое абстракции (очередь входящих соединений сокета, очередь необработанных запросов сервиса и т.д.). 

Service Time -  чистое время, необходимое системе для обработки запроса. 

Response Time - время отклика. Время от посылки запроса до получения ответа. Измеряется на стороне клиента.

Эти времена часто отображаются в виде процентилей. На практике для приближённого расчёта процентилей используются алгоритмы [forward decay](http://dimacs.rutgers.edu/~graham/pubs/papers/fwddecay.pdf), [t-digest](https://github.com/tdunning/t-digest/blob/master/docs/t-digest-paper/histo.pdf) и [HdrHistogram](https://github.com/HdrHistogram/HdrHistogram).


## Балансировка нагрузки (по мотивам [GitHub Network Load Balancer](https://githubengineering.com/glb-director-open-source-load-balancer/))
### ECMP
Routers have a feature called Equal-Cost Multi-Path (ECMP) routing, which is designed to split traffic destined for a single IP across multiple links of equal cost. ECMP works by hashing certain components of an incoming packet such as the source and destination IP addresses and ports. By using a consistent hash for this, subsequent packets that are part of the same TCP flow will hash to the same path, avoiding out of order packets and maintaining session affinity.

### L4/L7 split design
At the L4 tier, the routers use ECMP to shard traffic using consistent hashing to a set of L4 load balancers - typically using software like ipvs/LVS. LVS keeps connection state, and optionally syncs connection state with multicast to other L4 nodes, and forwards traffic to the L7 tier which runs software such as haproxy. We call the L4 tier “director” hosts since they direct traffic flow, and the L7 tier “proxy” hosts, since they proxy connections to backend servers.

This L4/L7 split has an interesting benefit: the proxy tier nodes can now be removed from rotation by gracefully draining existing connections, since the connection state on the director nodes will keep existing connections mapped to their existing proxy server, even after they are removed from rotation for new connections. Additionally, the proxy tier tends to be the one that requires more upkeep due to frequent configuration changes, upgrades and scaling so this works to our advantage.

If the multicast connection syncing is used, then the L4 load balancer nodes handle failure slightly more gracefully, since once a connection has been synced to the other L4 nodes, the connection will no longer be disrupted.


## DevOps как способ устранения конфликта Разработки и Сопровождения
Разработка заинтересована в том, чтобы иметь возможность как можно чаще "выкатывать" изменения. Любые изменения снижают стабильность системы.

Сопровождение заинтересовано в том, чтобы система работала (была стабильной).

Таким образом, Разработка и Сопровождение имеют противоположные точки зрения в вопросе управления жизненным циклом системы. Это неизбежно приводит к конфликту.

DevOps-подход предполагает привлечение Разработки к решению задач Сопровождения. Это приводит к тому, что Разработка делает систему более устойчивой к сбоям и удобной в сопровождении.

В рамках DevOps-подхода Разработка совместно с Сопровождением обеспечивают развитие системы поддерживая её стабильность в соответствии с SLA, который удовлетворяет бизнес-требованиям.


## DevOps - Зачем нужны контейнеры
Инфраструктура, конфигурация которой находится под ручным управлением, со временем накапливает недокументированные изменения, становится уникальной (неповторимой) и, в этом смысле, напоминает снежинку. В итоге, ручное управление конфигурацией "систем-снежинок" либо приводит к краху, либо - существенно замедляет эволюцию.

Выход заключается в использовании **immutable-инфраструктуры**, конфигурация которой хранится в виде кода и либо совсем не допускает изменений в runtime, либо - получает эти изменения из внешнего репозитория. Таким образом, конфигурация инфраструктуры становится "прозрачной" а сама инфраструктура - повторяемой и более надёжной.  

В контексте идеи immutable-инфраструктуры задача Архитектора заключается в определении ограниченного набора конфигурационных параметров, для которых возможность изменений должна сохраниться. Речь идёт о параметрах, обеспечивающих гибкость, необходимую для реализации основных функций. Изменение этих параметров должно происходить через задокументированный интерфейс.

Логичным развитием идеи immutable-инфраструктуры является идея **disposable-компонентов**, предлагающая отказаться от требования 100%-ой надежности и отказоустойчивости компонентов. Вместо этого архитектура должна обеспечивать возможность быстрой замены компонентов (такие компоненты должны быть stateless).

Движение "за  всеобщую контейнеризацию" отлично согласуется с идеями immutable infrastructure и disposable components ибо контейнеры представляют собой immutable-инфраструктуру а также - предоставляют инструменты для развёртывания disposable-компонентов внутри контейнеров.


## DevOps - Обратимость изменений
Любая информационная система, в которой происходят изменения, рано или поздно даст сбой. В надёжной системе сбой не приводит к отказу в обслуживании. Для достижения этой цели изменения, вносимые в систему, должны быть обратимы.

**Feature toggle** - один из вариантов достижения обратимости изменений - все изменения поставляются с "рубильниками", позволяющими управлять их активностью.

**Blue/green deployment** - ещё одна из DevOps практик, реализующая стратегию обратимых изменений.

Blue/green deployment предполагает наличие двух идентичных сред развёртывания - green и blue. В одной из сред развёрнута текущая версия системы, в другой - разворачивается новая версия. Если в процессе развёртывания новой версии возникает проблема, происходит переключение на среду с текущей версией. При успешном развёртывании новой версии - ей присваивается статус текущей а среда с предыдущей версией используется для дальнейшей разработки разработки.


## Базы данных - Реляционная модель. Теоретический минимум
Таблица реляционной модели, фактически, является n-арным отношением, она описывается схемой - перечнем артрибутов отношения и состоит из кортежей, принадлежащих отношению.

Ключ отношения - множество атрибутов отношения от которого функционально зависят все атрибуты отношения.

Первичный ключ - один из минимальных ключей отношения.

Реляционная модель определяет систему операции над отношениями - реляционную алгебру. Формально, реляционная алгебра не является декларативным языком так как определяет последовательность выполнения операций.

Операция произведения двух отношений формирует единое отношение, в котором каждому кортежу первого отношения сопоставляются все кортежи второго отношения. Кардинальность полученного отношения равна произведению кардинальностей исходных отношений.

Операция соединения выполняет произведение с последующей фильтрацией (удаляя кортежи, которые не удовлетворяют условию соединения). Условие соедиения описывается в терминах атрибутов результирующего отношения (куда входят все атрибуты исходных отношений). Таким образом, операция соединения формирует отношение, состоящиее из семантически связанных кортежей исходных отношений (принадлежат отношению условия объединения).

* 1NF - все атрибуты схемы отношения представлены скалярами.
* 2NF - в схеме отношения нет атрибутов, функционально зависящих от неполного ключа.
* 3NF - в схеме отношения нет транзитивных зависимостей между атрибутами.
* 4NF - в схеме отношения нет многозначных зависимостей (между группами значений атрибутов).

Критерии нормальности относятся исключительно к логической схеме (используется для моделирования объектов информационной системы) и могут нарушаться (из соображений повышения производительности) в схеме хранения (используется внутри СУБД). Таким образом, физические структуры хранения могут отличаться от логических структур, поскольку для них используются разные критерии эффективности.

Построение схемы реляционной БД начинается с описания атрибутов и функциональных зависимостей между ними. Далее - атрибуты объединяются в отношения (таблицы) для моделирования объектов информационной системы.


## Базы данных - Аномалии агрегирования в SQL
Count() в отличии от остальных аггрегирующих функций (sum, avg, min, max) учитывает null-значения. Поэтому, результат вызова avg() может отличаться от результата полученного при делении sum() на count().

Использование count() без group by всегда (даже в отсутствии в выборке строк) возвращает одну строку:
```
select count(*) from table t where 1 <> 1;
```
вернёт строку со значением 0

при использовании group by, в отсутствии данных в выборке, возвращается пустой результат:
```
select count(*) from table t where 1 <> 1 group by t.some;
```
не вернёт ничего.


## Базы данных - Согласованность и транзакции
Одно из определений транзакций звучит как "группа операций, переводящая СУБД из одного согласованного состояние в другое". Это определение допускает, что в ходе выполнения транзакции согласованность может нарушаться (но должна быть восстановлена при завершении транзакции).

Таким образом, в контексте транзакции, речь идёт не о той согласованности, которая обеспечивается ограничениями схемы данных, за которыми следит СУБД - эти ограничение не могут быть нарушены никогда.

В контексте транзакции, речь идёт о "логической" (или бизнес) согласованности данных. 

p.s.
Ограничения схемы данных, за которыми следит СУБД, лучше называть **целостностью**.


## Базы данных - Техника реализации изоляции read committed
Большинство современных БД предотвращают «грязные» операции чтения следующим образом: 
1. База запоминает для каждого изменяемого объекта как старое зафиксированное значение, так и новое, устанавливаемое транзакцией, удерживающей в данный момент блокировку записи. 
2. Во время выполнения транзакции всем другим транзакциям, читающим объект, возвращается старое значение. 
3. Только после фиксации нового значения транзакции начинают получать его при чтении.

На данном уровне изоляции блокируется лишь совместная запись в один и тот же объект. При этом, для чтения объект продолжает быть доступен. Однако, прочитанные данные в любой момент могут устареть. Таким образом, уровень изоляции Read committed, "в чистом виде" (без использования приёмов, описанных [далее](#prevets-lost-updates)), не подходит для реализации "наивного" счётчика (прочитать-изменить-сохранить)


## Базы данных - Техника реализации изоляции repeatable read
Идея состоит в том, что:
1. БД хранит все **актуальные** (доступные из исполняющихся транзакций) версии строки
2. с каждой версией строки связаны два поля, в которых хранятся идентификаторы транзакций, соответственно, создавшей и удалившей данную версию строки.

Таким образом:
1. во время исполнения транзакции, у БД есть возможность передать в транзакцию ту версию строки, которая была актуальной на момент запуска транзакции.
2. после завершения транзакции, БД получает возможность удалить устаревшие и неиспользуемые версии строк.

В результате, БД способна выполнять длительные запросы на чтение, продолжая в то же время обработку операций записи, без какой-либо конкуренции блокировок между ними.

p.s. Repeatable read изоляция не универсальна и должна применяться осознанно. В одних случаях например - в аналитических запросах) она помогает сохранять согласованное состояние продолжительное время. В других - например, для реализации логики compare and set, наоборот - создаёт сложности ибо эффективно скрывает изменения, выполняемые в параллельных транзакциях.


## <a name="prevets-lost-updates"></a>Базы данных - Предотвращение потери обновлений
На практике, транзакции в реляционных БД выполняются на уровнях изоляции repeatable read или read committed. При этом, часто разработчики не отдают себе отчёт в том, что использование этих уровней изоляции не гарантирует защиту от потери обновлений (например, не позволяют реализовать "наивный" счётчик, использующий паттерн read-change-update).

Для корректной реализации счётчика можно использовать следующие варианты:
1. Атомарные внутри БД операции вида: 
```
update counters set value = value + 1
```
2. Пессимистичные блокировки: 
```
   begin
   select .... for update  
   update ...
   commit
```
3. Оптимистичные блокировки (паттерн **compare and set**, который работает даже в отсутсвии транзакций):
```
   select value from counters;
   update counters set value = new_value where value = old_value;
```
p.s. На уровне изоляции Repeatable read PostgreSQL (в Oracle он называется serializable а в SQL Server - snapshot isolation) БД автоматически обнаруживает потерянные обновления и прерывает откатывает транзакцию. Однако, MySQL этого не делает.

p.p.s. В распределённой БД для предотвращения потери обновлений нужно использовать CRDT-структуры данных (ибо подходы с использованием блокировок и CAS предполагают единый источник данных - теряют полезность в случае распределённых БД).


## Базы данных - Аномалии конкурентного выполнения транзакций
1. Потеряное обновление (грязная запись)
2. Грязное чтение 
3. Не согласованное чтение
4. Фантомное чтение

Спопособы исключения аномалий:
\[1] и \[2] - использовать изоляцию выше read committed
\[1] - использовать атомарные операции изменения, CAS (where) или блокировки (select for update)
\[3] и \[4]- select for update а также (в качестве "последней надежды") - использовать update вместо insert - эта техника называется "материализация конфликтов" - конфликт вызовет блокировку, которая будет обнаружена и предотвратит потерю согласованности. 


## Базы данных - Двухфазная блокировка (2PL)
Двухфазная блокировка - алгоритм, реализуемый диспетчером транзакций в СУБД. Используется для достижения изоляции и предотвращения взаимного блокирования.

Суть алгоритма в том, что выполнение транзакции делится на две **не пересекающиеся** фазы:
1. Получение блокировок.
2. Возврат блокировок.

Таким образом, вернув любую блокировку нельзя запрашивать новые. Это ограничение обозначает порядок операций и защищает от взаимного блокирования.


## Базы данных - Архитектура LSM-БД
Записываемые в БД данные попадают в структуру MemTable, которая хранится в памяти и представляет собой сбалансированное дерево (например, AVL или красно-чёрное).

При записи в MemTable данные дублируются в журнале (write ahead log), который используется для восстановления MemTable в случае фатального сбоя.

При достижении MemTable порогового размера данные сохраняются на диск в виде структуры SSTable (отсортированная по ключу последовательность записей), которая называется сегмент. После сохранения содержимого MemTable в SSTable, создаются новые MemTable и журнал.

Периодически, над сегментами SSTable выполняется операция объединения в ходе которой сохраняются только актуальные записи. Объединение происходит в фоновом процессе и не влияет на текущие операции чтения. После завершения объединения выполняется атомарная операция переключения на объединённый сегмент.

При чтении, БД сначала просматривает  MemTable а затем - сегменты SSTable. Поиск в сегментах SSTable ускоряется за счёт использования фильтра Блума и разряжённого hash-индекса (хранит ссылки на блоки записей, поиск внутри блока реализуется сканированием).

### Сильные стороны:
* быстрая операция записи в БД - выполняется в памяти (в Memtable) с соответствующим дублированием в журнале на диске (append only log)
* быстрая операция синхронизации содержимого Memtable в сегменты на диске (SSTable) - производится последовательно (эффективно)
* данные внутри SSTable отсортированы по ключу (эффективно для поиска и слияния)
* данные внутри SSTable не модифицируются (нет необходимости искать позицию для обновления)

### Слабые стороны:
* потенциально, "дорогая" операция чтения "старых" (давно записывались) данных - нужно искать среди сегментов на диске
* write amplification - каждый update создаёт новую копию данных (до завершения операции объединения сегментов)

### Использование:
* LevelDB
* RocksDB
* Cassandra
* HBase
* Lucene


## Тонкости Java - Неожиданная польза от intern()
В классе String есть intern(), который помещает строку в JVM string pool и позволяет получить ссылку на "каноническое представление строки". На практике этот метод используется редко ибо современные JVM умеют эффективно хранить стороки - нет необходимости инициировать интернирование строк внучную.

Однако, существует случай в котором метод intern() оказывает очень полезен - запись вида:
```
public static final String PUBLIC_STRING = "reusable public string";
```
приводит к тому, что код, зависящий от PUBLIC_STRING, получит его значение ***уже на стадии компиляции***.

Таким образом, ***при необходимости изменить значение PUBLIC_STRING, необходимо перекомпилировать весь код, использующий PUBLIC_STRING***.

Для исправления ситуации нужно сделать, чтобы PUBLIC_STRING перестала быть константой времени компиляции а вычислялось на runtime. Для этого можно использовать вызов метода intern() - ***"reusable public string".intern()***

В этом случае код, зависящий от PUBLIC_STRING будет на runtime обращаться к полю класса (не использовать значение "захардкоженное" на этапе компиляции).


## Тонкости Java - ClassNotFoundException vs NoClassDefFoundError
ClassNotFoundException это checked-исключение, оно используется для обозначения кода,  о котором **заранее известно**, что он может пытаться загрузить (например, в результате вызова Class.forName() или ClassLoader.loadClass()) классы, отсутствующие в classpath. 

ClassNotFoundException генерируется при **explicit** (явно, из кода приложения) попытке загрузить класс, которого нет в classpath.

Код приложения может обработать ClassNotFoundException и продолжить выполнение по альтернативному сценарию.

NoClassDefFoundError это ошибка (не исключение).  Она генерируется JVM при не явной (implicit) попытке загрузить класс, который отсутствует в classpath. Это происходит на этапе загрузки классов внутри jvm.

Как правило, после возникновения NoClassDefFoundError приложение завершается - не предусматривает код для обработки этой ошибки.


## Java memory model
Описывает гарантии языка Java  отношении работы со встроенными в язык типами данных, расположенными в памяти (куче, не на стеке) многопоточной программы. В частности:
1. Атомарность чтения/записи 
2. Отсутствие word-tiring (запись не искажает содержимое в "соседних" ячейках)
3. Обеспечение безопасной публикации (переноса состояния) между потоками через механизм release-acquire  (операции синхронизируются парами synchronized action)
4. Обеспечение безопасной публикации между потоками через механизм freeze-action (публикация ссылки на сконструированный объект должна происходить после завершения freeze-action - после того как значения final-полей объекта станут "видны" в любом потоке).

Замечания:
* специфицируется работа с данными только в куче (не на стеке)
* специфицируется работа только со втроенными в язык типыми
*  к synchronized action относятся операции volatile read/write, lock unlock monitor, первая/последняя операция в потоке, операция завершения потока
* synchronized action должны использовать "парами" -  не достаточно выполнить только одну операцию из пары (например, volatile write)

Таким образом, гарантии предоставляемые Java memory model, позволяют достигать (обосновывать) синхронизации в многопоточных программах.

ps. Артефакт не синхронизированного чтения (инициализация объекта, на который ссылается х, выполняется в другом потоке):
```
T x;
...
if (x != null) {
  x.m() // может сгенерировать NPE
}
```
Дело в том, что здесь ***две независимые*** операции чтения х и нет никаких ограничений на порядок их выполнения.

Для исключения NPE необходимо преобразовать код, так чтобы была ***одна***  операция чтения:
```
T tmp = x;
if (tmp != null) {
 tmp.m()
}
```

## Управление - Планирование
Планируя разработку **новой** системы нужно быть готовым к тому, что её первая версия будет выброшена и переписана с нуля. Причина в том, что при разработке первой версии **неизбежно** возникнут **скрытые** проблемы. Фактически - цель работы над первой версией системы заключается не в получении законченного продукта, а в обнаружении максимального количества скрытых проблем.


## Управление - Проблема координации изменений кода
Возникает в любом проекте естественным образом в результате процесса повышения энтропии (усложнения системы).

Для решения проблемы координации изменений нужно поддерживать слабую связность между компонентами системы. Достичь этого можно двумя подходами:
1. Архитектурой - например, микросервисной, либо - модуляризацией монолита
2. Инженерными практиками - например, CI-автоматизацией, обеспечивающей обратную связь
