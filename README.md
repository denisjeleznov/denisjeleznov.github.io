## Объекты vs Структуры данных

Структуры данных - можно сравнить со стандартными блоками конструктора LEGO. Они реализуют хорошо известные (часто используемые) абстракции и формируют базу для реализации Объектов. 

Работа программиста (написание кода программы) заключается в том, чтобы сформулировать решение задачи на "человеческом" языке а затем - трансформировать это решение в компьютерный язык (реализовать Объекты и их взаимодействие через методы).

Объекты **скрывают** структуру своих данных. Структуры - напротив, позволяют работать со своими данными **напрямую**.

ArrayList и LinkedList из JDK, формально, являются объектами классов, однако, по сути, это структуры - работа с ними **предполагает знание внутреннего устройства**.


## Concurrency vs Parallelism
Concurrency is an aspect of the problem domain — your program needs to handle multiple simultaneous (or near-simultaneous) events. Parallelism, by contrast, is an aspect of the solution domain.

Concurrency is not a way to make a program run faster. It is not a complex juggling trick that ninja coders use to keep multiple balls in the air at one time. On the contrary, it is the apparent sequential execution of a program that is the complex trick. Sequential execution is an illusion maintained by a cabal of compiler writers and hardware architects. Concurrency is simply the relaxation of a fabricated constraint.”

(C) Meike, G. Blake. “Android Concurrency”

Таким образом, современный runtime практически всегда предполагает конкурентное выполнение кода. В этом смысле, Concurrency напоминает Р-компонент из знаменитой CAP-теоремы. Они оба - "данность" современного мира разработки ПО (должно работать в многоядерном runtime и уметь горизонтально масштабироваться по множеству узлов - быть partition tolerance).


## Функциональное программирование vs Объектно ориентированное в условиях современного runtime
Выбор подхода к разработке ПО для современной конкурентной среды выполнения (concurrency runtime) в первую очередь зависит от способа работы с данными.

ООП предполагает **совместный** доступ к данным внутри объекта из методов объекта. Конкурентная среда выполнения создаёт условия для **одновременного** доступа к данными, что приводит к  возникновению неопределённостей типа "гонки" (race condition). Устранение неопределённости требует синхронизации что существенно влияет на производительность (фактически, "засинхронизированный" многопоточный код выполняется медленнее однопоточного).

В функциональном подходе данные представляются в "математическим" смысле (результат работы функции не может изменить её аргументы) а работа с ними напоминает конвейер. В этом подходе, практически, отсутствует проблема совместного доступа к данным, однако, требуются дополнительные ресурсы на обеспечение независимости данных (много операций копирования - больше нагрузка на подсистему управления памятью).

Таким образом, становится очевидным причина возобновления интереса к функциональному подходу для создания систем, эффективно работающих в современных runtime.

## Определение Архитектуры (по ГОСТ)
Архитектура - принципиальная организация системы, воплощённая в её элементах, способах их взаимоотношений  друг с другом и со средой а также - принципы, направляющие развитие системы.

Неожиданно для меня, ГОСТ-определение архитектуры ПО оказалось на лидером по количеству смысла на единицу текста.

## Основное требование к архитектуре ПО
Исторически, программное обеспечение (softwate vs hardware) появилось в ответ на требование обечпечить гибкость - легко и быстро менять поведение машин. Для обеспечения гибкости, нужно как можно дольше иметь как можно больше вариантов развития (эволюции) системы.

Таким образом, хорошая архитектруа должна **обеспечивать высокую скорость эволюции информационной системы**, что достигается за счёт:
1. предоставления разнообразия вариантов использования
2. лёгкости разработки, тестирования, развёртывания и сопровождения

Поэтому, при разработке архитектуры основной акцент внимания уделяется не реализации функциональных требований на текущий момент а обеспечению развития (эволюции) системы во времени.

**Архитектура** программной системы — это **форма**, которая образуется делением системы на **компоненты**.  

Любую программную систему можно, условно, разделить на два основных компонента:              
1. ядро (бизнес-логика). 
2. оболочка (взаимодействие бизнес-логики с окружением).

Цель архитектора — создать такую форму, которая сделает ядро самым важным компонентом, а оболочку — не зависимой от ядра. Это позволит откладывать и задерживать принятие решений об оболочке для того, чтобы накопить информацию (во время работы над ядром) для обоснованного выбора.

## Источник вдохновения для проектирования информационной системы
Поиск метафоры в "мире механизмов" (механических систем) обречён на провал из-за того, что механические системы, как правило, сочетают в себе те черты, которых нужно избегать при проектировании информационных систем - хрупкость и жёсткость.

Аналогии нужно искать в биологии.


## Принципы проектирования и сопровождения высоконагруженной системы:

### Принципы проектирования:
1.	Разбиение на блоки – распределение нагрузки
2.	Резервирование подсистем – устойчивость к внутренним отказам
3.	Автономность – устойчивость к отказам внешних систем


### Принципы развёртывания:
1.	Плавность – последовательное внедрение (пилотный блок, основной блок, резервный блок)
2.	Рубильники – возможность оперативного включения/отключения/переключения версии индивидуально для каждого изменения
3.	Обратная совместимость изменений


## Надёжность распределённой системы. Паттерн "Наблюдение"
Система считается надёжной, если сбой в одном или нескольких её компонентов не приводит к отказу - система продолжает предоставлять сервис с заявленными параметрами качества.

Один из шаблонов для реализации надёжной системы - "Наблюдение" (supervision) предполагает эскалацию "проблем" при вызове сервиса его "Наблюдателю" (supervisor). В данном контексте, к "проблемным" относятся ситуации, возникновения системных (инфраструктурных) ошибок, например, потери соединения с БД или внешним сервисом. 

Применение шаблона "Наблюдение" позволяет отделить кодовую базу обработки ошибок бизнес-логики от логики обработки системных ошибок. При использовании этого шаблона важно чётко "соблюдать водораздел" - "Наблюдатель" может управлять жизненным циклом объектов наблюдения, но не должен знать о деталях реализуемой ими бизнес-логики.

Шаблон "наблюдение" широко используется в модели программирования, основанной на акторах, а также - в решениях для балансировки нагрузки.


## Доступность распределённой системы - всегда компромисс
Информация в физическом мире распространяется с конечной скоростью - изменения в распределённой системе не могут моментально появиться во всех её частях. CAP-теорема, фактически, постулирует это ограничение в отсутствии возможности создать распределённую систему со 100% доступностью.

Доступность реальной распределённой системы это компромисс между ограничениями физического мира, финансовыми рисками и удобством использования. Например, в случае отсутствия связи с банком, банкомат не откажет в выдаче денег (сервис доступен), но ограничит максимально запрашиваемую сумму (в рамках установленных финансовых рисков).
