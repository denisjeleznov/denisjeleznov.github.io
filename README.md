## Объекты vs Структуры данных

Структуры данных - можно сравнить со стандартными блоками конструктора LEGO. Они реализуют хорошо известные (часто используемые) абстракции и формируют базу для реализации Объектов. 

Работа программиста (написание кода программы) заключается в том, чтобы сформулировать решение задачи на "человеческом" языке а затем - трансформировать это решение в компьютерный язык (реализовать Объекты и их взаимодействие через методы).

Объекты **скрывают** структуру своих данных. Структуры - напротив, позволяют работать со своими данными **напрямую**.

ArrayList и LinkedList из JDK, формально, являются объектами классов, однако, по сути, это структуры - работа с ними **предполагает знание внутреннего устройства**.


## Concurrency vs Parallelism
Concurrency is an aspect of the problem domain — your program needs to handle multiple simultaneous (or near-simultaneous) events. Parallelism, by contrast, is an aspect of the solution domain.

Concurrency is not a way to make a program run faster. It is not a complex juggling trick that ninja coders use to keep multiple balls in the air at one time. On the contrary, it is the apparent sequential execution of a program that is the complex trick. Sequential execution is an illusion maintained by a cabal of compiler writers and hardware architects. Concurrency is simply the relaxation of a fabricated constraint.”

(C) Meike, G. Blake. “Android Concurrency”

Таким образом, современный runtime практически всегда предполагает конкурентное выполнение кода. В этом смысле, Concurrency напоминает Р-компонент из знаменитой CAP-теоремы. Они оба - "данность" современного мира разработки ПО (должно работать в многоядерном runtime и уметь горизонтально масштабироваться по множеству узлов - быть partition tolerance).


## Функциональное программирование vs Объектно ориентированное в условиях современного runtime
Выбор подхода к разработке ПО для современной конкурентной среды выполнения (concurrency runtime) в первую очередь зависит от способа работы с данными.

ООП предполагает **совместный** доступ к данным внутри объекта из методов объекта. Конкурентная среда выполнения создаёт условия для **одновременного** доступа к данными, что приводит к  возникновению неопределённостей типа "гонки" (race condition). Устранение неопределённости требует синхронизации что существенно влияет на производительность (фактически, "засинхронизированный" многопоточный код выполняется медленнее однопоточного).

В функциональном подходе данные представляются в "математическим" смысле (результат работы функции не может изменить её аргументы) а работа с ними напоминает конвейер. В этом подходе, практически, отсутствует проблема совместного доступа к данным, однако, требуются дополнительные ресурсы на обеспечение независимости данных (много операций копирования - больше нагрузка на подсистему управления памятью).

Таким образом, становится очевидным причина возобновления интереса к функциональному подходу для создания систем, эффективно работающих в современных runtime.

## Определение Архитектуры (по ГОСТ)
Архитектура - принципиальная организация системы, воплощённая в её элементах, способах их взаимоотношений  друг с другом и со средой а также - принципы, направляющие развитие системы.

Неожиданно для меня, ГОСТ-определение архитектуры ПО оказалось на лидером по количеству смысла на единицу текста.

## Основное требование к архитектуре ПО
Исторически, программное обеспечение (softwate vs hardware) появилось в ответ на требование обечпечить гибкость - легко и быстро менять поведение машин. Для обеспечения гибкости, нужно как можно дольше иметь как можно больше вариантов развития (эволюции) системы.

Таким образом, хорошая архитектруа должна **обеспечивать высокую скорость эволюции информационной системы**, что достигается за счёт:
1. предоставления разнообразия вариантов использования
2. лёгкости разработки, тестирования, развёртывания и сопровождения

Поэтому, при разработке архитектуры основной акцент внимания уделяется не реализации функциональных требований на текущий момент а обеспечению развития (эволюции) системы во времени.

**Архитектура** программной системы — это **форма**, которая образуется делением системы на **компоненты**.  

Любую программную систему можно, условно, разделить на два основных компонента:              
1. ядро (бизнес-логика). 
2. оболочка (взаимодействие бизнес-логики с окружением).

Цель архитектора — создать такую форму, которая сделает ядро самым важным компонентом, а оболочку — не зависимой от ядра. Это позволит откладывать и задерживать принятие решений об оболочке для того, чтобы накопить информацию (во время работы над ядром) для обоснованного выбора.

## Источник вдохновения для проектирования информационной системы
Поиск метафоры в "мире механизмов" (механических систем) обречён на провал из-за того, что механические системы, как правило, сочетают в себе те черты, которых нужно избегать при проектировании информационных систем - хрупкость и жёсткость.

Аналогии нужно искать в биологии.


## Принципы проектирования и сопровождения высоконагруженной системы:

### Принципы проектирования:
1.	Разбиение на блоки – распределение нагрузки
2.	Резервирование подсистем – устойчивость к внутренним отказам
3.	Автономность – устойчивость к отказам внешних систем


### Принципы развёртывания:
1.	Плавность – последовательное внедрение (пилотный блок, основной блок, резервный блок)
2.	Рубильники – возможность оперативного включения/отключения/переключения версии индивидуально для каждого изменения
3.	Обратная совместимость изменений


## Надёжность распределённой системы. Паттерн "Наблюдение"
Система считается надёжной, если сбой в одном или нескольких её компонентов не приводит к отказу - система продолжает предоставлять сервис с заявленными параметрами качества.

Один из шаблонов для реализации надёжной системы - "Наблюдение" (supervision) предполагает эскалацию "проблем" при вызове сервиса его "Наблюдателю" (supervisor). В данном контексте, к "проблемным" относятся ситуации, возникновения системных (инфраструктурных) ошибок, например, потери соединения с БД или внешним сервисом. 

Применение шаблона "Наблюдение" позволяет отделить кодовую базу обработки ошибок бизнес-логики от логики обработки системных ошибок. При использовании этого шаблона важно чётко "соблюдать водораздел" - "Наблюдатель" может управлять жизненным циклом объектов наблюдения, но не должен знать о деталях реализуемой ими бизнес-логики.

Шаблон "наблюдение" широко используется в модели программирования, основанной на акторах, а также - в решениях для балансировки нагрузки.


## Компромисс между доступностью и согласованностью распределённой системы
Информация в физическом мире распространяется с конечной скоростью - изменения в распределённой системе не могут моментально появиться во всех её частях. CAP-теорема, фактически, постулирует это ограничение в отсутствии возможности создать распределённую систему со 100% доступностью и согласованностью.

Доступность и согласованность реальной распределённой системы это компромисс с ограничениями физического мира, финансовыми рисками и удобством использования. 

Например, в случае отсутствия связи с банком, банкомат не откажет в выдаче денег (сервис доступен), но ограничит максимально запрашиваемую сумму (в рамках установленных финансовых рисков).

Другой пример - CRDT-структуры данных, использованием которых предполагает, что система доступна, но периодически находится в не согласованном состоянии.


## Изолированная согласованность
Реализация строгой (в каждой точке, в любой момент времени) согласованности в распределённой системе не достижима из-за конфликта требования по доступности с конечной скоростью распространения информации.

Изолированная согласованность это компромиссное решение, которое предполагает поддержание согласованности только в рамках отдельных частей системы - "автономных доменов". 

Изолированная согласованность достижима за счёт того:
1.	что данные внутри домена не распределены
2.	транзакции не выходят за рамки домена.

Одна из задач, решаемых в ходе разработки архитектуры распределённой системы - выделение "автономных доменов" данных. Как правило, границы доменов определяются границами **бизнес**-транзакций.

Для перемещения данных между "автономными доменами" используется паттерн "сага".


## Распределённая блокировка
Традиционно, для организации монопольного доступа к ресурсу используются блокировки.

В случае распределённых систем эффективная реализация блокировки требует дополнительной проверки на стороне стороне ресурса - он должен проверять не только наличие маркера доступа но и его версию.

Например, узел А получает маркер доступа к ресурсу, запускает операцию и... впадает в ступор, например, из-за начавшейся сборки мусора. За это время маркер доступа узла А к ресурсу "протухает" и доступ к ресурсу получает узел B. 

Через некоторое время, узел А "просыпается" и решает продолжить операцию с ресурсом (состояние которого уже было изменено узлом B) - возникает конфликт.

Для того, чтобы избежать конфликта, при обработке запроса ресурс должен проверять не только наличие маркера доступа, но и его версию и откатывать операции с "протухшей" версией маркера.


## Latency vs Response Time vs Service Time
Latency - время ожидания. Это время которое запрос ожидает начала его обработки. Ожидающий запрос, обычно, находится в очереди на соответствующем слое абстракции (очередь входящих соединений сокета, очередь необработанных запросов сервиса и т.д.). 

Service Time -  чистое время, необходимое системе для обработки запроса. 

Response Time - время отклика. Время от посылки запроса до получения ответа. Измеряется на стороне клиента.

Эти времена часто отображаются в виде процентилей. На практике для приближённого расчёта процентилей используются алгоритмы [forward decay](http://dimacs.rutgers.edu/~graham/pubs/papers/fwddecay.pdf), [t-digest](https://github.com/tdunning/t-digest/blob/master/docs/t-digest-paper/histo.pdf) и [HdrHistogram](https://github.com/HdrHistogram/HdrHistogram).
